## 对象已死？
在堆里买呢存放着几乎所有的对象实例，垃圾回收器在对堆进行来及回收之前，需要判断哪些对象还存活着
### 1. 引用技术法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，当引用失效时，计数器减1。当任何时刻计数器为0时的对象就是不可能在被使用的。

```java

public class ReferenceCountingGC{

    public Object instance=null􏳀;
    private static final int_1MB = 1024*1024􏳀;
    /** *􏰶􏱭􏰜􏶠􏴾􏳨􏰝􏶍􏰒􏴌􏵅􏱘􏱋􏷊􏴩􏰉􏰊􏰠􏲤􏷋􏳴􏱒GC􏴇􏴈􏲯􏱹􏴅􏴆􏱋􏴙􏴺􏱣􏰅􏱫 */
    private byte[]bigSize=new byte[2*_1MB]􏳀

    public static void testGC􏰰􏰱{
        ReferenceCountingGC objA=new ReferenceCountingGC􏰰􏰱􏳀 ;
        ReferenceCountingGC objB=new ReferenceCountingGC􏰰􏰱􏳀;
        objA.instance=objB􏳀;
        objB.instance=objA􏳀;
        objA=null􏳀;
        objB=null􏳀;
        System.gc􏰰􏰱􏳀;
    }
}
```
客观地说，引用计数法的实现简单，判定效率也高，在大部分情况下它都是不错的算法。但是主流的 Java 虚拟机里没有选用引用计数法来管理内存，其中主要原因时它很难解决对象之间循环引用的问题。

### 可达性分析算法
在主流的商用程序设计语言的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路是通过一席勒的称为"GC ROOTs"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象
到达 GC Roots 没有任何引用链时，则证明这个对象是不可用的。

在 Java 语言中，可以作为 GC Roots 的对象包括下面几种
- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI 引用的对象

## 再谈引用
- 强引用：  
   强引用是指代码中普遍存在的，类似 Obj obj = new Obj() 这类的引用，只要引用还在，垃圾回收器永远不会回收掉被引用的对象
   
- 软引用：  
  软引用是用来描述一些还有用，但并非必需的对象。对于软引用关联对象，在系统要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收，如果回收之后还没有足够的内存，那么才会抛出异常
  
- 弱引用：  
  弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关闭的对象只能生存到下一次来及回收之前，当垃圾回收工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用   
  虚引用也称为幽灵引用，它是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存事件构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能大对象被回收时收到一个系统通知
  
  
## 生存还是死亡

  即时在可达性算法分析中不可达的对象，也并非是"非死不可"的，这时候它们暂时处于"缓行"阶段，要真正宣告一个对象的死亡，至少要经历两个阶段：
  1. finalize 方法，第一次筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，都将"没有必要执行"
  2. 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F_Queue 的队列中，并在稍后由一个虚拟机自动创建的、低优先级的 Finalizer 线程去执行它。这里所谓的执行，是指虚拟机会触发这个
  方法，但并不承诺会等待它运行结束。如果在 finalize 方法中没有把对象指向某个引用，那么它就会被回收。
  
  
   
# 垃圾回收算法  
由于垃圾收集算法的实现设计大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此我们只讨论算法的思想

### 1. 标记-清除算法
最基础的收集算法是"标记-清除"算法，如同它的名字一样，算法分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，
它的标记过程其实就是判定对象是否死亡的过程。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的不足主要是：
一个是效率问题，标记和清除两个过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能导致以后程序运行过程中需要
分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。
### 2. 复制算法

为了解决效率问题，一种"复制"的收集算法出现了，它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块
上面，然后再把已使用过的内存空间一次清除掉。这样使得每次都是对整个半区进行内存回收，也就不用考虑内存碎片的问题，只要移动堆顶的指针就可以。只是这种算法的代价是
将内存缩小了原来的一半，代价太大。

现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%都是"朝生夕死"的，所以并不需要按照1：1的比例来划分内存空间，而是
将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活的对象一次性
复制到另一块 Survivor 空间上，最后清理掉 Eden 和 刚才用过的 Survivor 空间。 HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是8：1，也就是每次新生代
中可用内存为整个空间为新生代容量的90%，只有10%会被浪费。当然98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多余10%的对象存活，当
 Survivor 空间不够用时，需要依赖其他内存（老年代）进行分配担保。
 
### 3. 标记整理算法

复制收集算法在对象存活率较高时脚要进行较多的复制操作，效率将会变低。更关键的是，空间浪费。

根据老年代的特点，有人提出了一种"标记-整理"算法，标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存活的对象都向一端
移动，然后直接清除掉端边界以外的内存。

### 4. 分代收集算法
当前商业虚拟机都是采用"分代"收集算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同，将内存划分成几块。一般把 Java 堆分成新生代和老生代，这样就
可以根据各个年代的特点选择适合的算法。在新生代中，每次垃圾回收时发现又大批量对象死去，只有少数存活，那就选用复制算法。而老年代的对象存活率高、没有额外空间
对他进行分配担保，就需要使用"标记-清除"或者"标记-整理"
   