并发事务访问相同记录的情况大致可分为3种
- 读一读：即并发事务相继读取相同的记录  
   读取操作本身并不会对记录有影响，所以允许这种情况发生
- 写一写：并发事务相继对相同的数据作出改动  
    在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交的事务相继对一条记录做改动时，需要让它们排队，这个排队的过程是通过锁来实现的。这个所谓的锁其实是内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的。
- 读-写或者写-读
    这种情况下可能会发生脏读、不可重复读、幻读

方案一，读操作利用多版本并发控制（MVCC）,写操作进行加锁
方案二，读、写操作都采用加锁的方式

## 锁定读
### 共享锁和独占锁
- 共享锁，英文名 Shared Locks ，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。
- 独占锁，也叫排他锁，英文名 Exclusive Locks ，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。

假如事务T1首先获取了一条记录的S锁，事务T2接着也要访问这条记录：
- 如果事务T2想要再获取一个记录的S锁，那么事务T2也会获得该锁，也就意味着事务T1和T2在该记录上同时持有S锁。
- 如果事务T2想要再获取一个记录的X锁，那么此操作会被阻塞，直到事务T1提交之后将S锁释放掉。

如果事务T1首先获取了一条记录的X锁，那么不管事务T2接着想获取S锁还是X锁，都会被阻塞，直到事务T1提交。

### 锁定读的语句

- 对读取的记录加锁 
```SQL
    SELECT ... LOCK IN SHARE MODE;
```
也就是在普通的 SELECT 语句后面加上 LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会给读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁，但是不能获取这些记录的X锁。

- 对读取的记录加X锁
```SQL
    SELECT ... FOR UPDATE
```
如果当前事务执行了该语句，那么它会为读取的记录加X锁，这样既不允许其他的事务获取这些记录的X锁，也不允许获取S锁。

## 写操作
 - DELETE:  
  删除操作的过程其实是现在B+树中定位到这条记录的位置，然后获取一下整条记录的X锁，然后执行 delete mask 操作。可以把这个定位待删除记录在B+树中的位置过程堪称是一个获取X锁的锁定读。

- UPDATE:  
  对
