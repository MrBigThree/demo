### 数据页

MySQL 抽象出一个数据页的概念，所有的IO操作都是以数据页为基本单位的。MySQL 会把数据页从磁盘加载到 Buffer Pool 里面。    
对于每一个缓存页，都有一个描述信息，用来描述缓存页，比如：这个数据页所属表空间、数据页的编号、这个缓存页在 Buffer Pool 
中的地址等信息。

### free 链表

数据库在启动的时候，会把Buffer Pool 分成很多个缓存页，每个缓存页默认16kb。所有空闲的缓存页会组成一个free 链表，他是一个双向链表。
在这个free 链表里面，每个节点就是缓存页的描述数据块地址，数据描述里面会有free_pre和free_next 两个指针。 

初始的时候所有的缓存页都在free链表里面，当缓存页被使用时，会从free 链表里面移除。


### hash表
数据库中还会有一个Hash结构表，用表空间号和数据页作为key，缓存页的地址作为value。当需要使用一个数据页的时候，通过 "表空间号和数据页号"作为key去hash表
查一下，如果存在的话就从Buffer Pool里面查找，如果不存在的话就从磁盘加载到Buffer Pool中。


### flush 链表

当数据发生变更之后，并不会直接存储到磁盘上，直接更新的是 Buffer Pool 中的缓存页，后台的IO进程会不定时的把数据刷入到磁盘上，所以就会出现一个问题，
就是磁盘上的数据和Buffer Pool里面的数据不一致，就产生了脏页。    

所有的脏页会组成一个flush 链表，跟free 链表类似的，flush 链表也是一个双向链表，在数据描述块上，记录了pre 和next指针。


### LRU 淘汰Buffer Pool中的数据页

所有非空闲的数据页会组成一个LRU链表。当Buffer Pool满了的时候，会淘汰其中缓存命中率最低的缓存页。   
PS:当然事实上，LRU链表并不是这么简单。假设全表扫描的时候，会把所有的数据全部加载到Buffer Pool 里面，如果淘汰掉其他的缓存页，显然是不合理的。


### 通常会给Buffer Pool 设置机器内存的50-60%，而且可以设置多个Buffer Pool



